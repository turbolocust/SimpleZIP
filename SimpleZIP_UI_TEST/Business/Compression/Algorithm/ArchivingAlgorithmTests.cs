// ==++==
// 
// Copyright (C) 2022 Matthias Fussenegger
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// ==--==

using FluentAssertions;
using ICSharpCode.SharpZipLib.Core;
using ICSharpCode.SharpZipLib.Zip;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SimpleZIP_UI.Business.Compression;
using SimpleZIP_UI.Business.Compression.Algorithm;
using SimpleZIP_UI.Business.Compression.Algorithm.Factory;
using SimpleZIP_UI.Business.Compression.Algorithm.Options;
using SimpleZIP_UI.Business.Util;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using Windows.Storage;

namespace SimpleZIP_UI_TEST.Business.Compression.Algorithm
{
    [TestClass]
    public sealed class ArchivingAlgorithmTests
    {
        private const string ArchiveName = "simpleZipUiTestArchive";
        private readonly StorageFolder _workingDir = ApplicationData.Current.TemporaryFolder;

        [DataRow(Archives.ArchiveType.Zip, ".zip")]
        [DataRow(Archives.ArchiveType.Tar, ".tar")]
        [DataRow(Archives.ArchiveType.TarGz, ".tgz")]
        [DataRow(Archives.ArchiveType.TarBz2, ".tbz2")]
        [DataRow(Archives.ArchiveType.TarLz, ".tlz")]
        [DataTestMethod]
        public async Task CompressAsync_ShouldCreateProperArchive(Archives.ArchiveType archiveType, string fileNameExtension)
        {
            const int updateDelayRate = 100;

            var compressionOptions = new CompressionOptions(Encoding.UTF8);
            var algorithmOptions = new AlgorithmOptions(updateDelayRate);
            var algorithm = AlgorithmFactory.DetermineAlgorithm(archiveType, algorithmOptions);

            bool isSuccess = await PerformArchiveOperations(
                    algorithm, fileNameExtension, compressionOptions)
                .ConfigureAwait(false);

            isSuccess.Should().BeTrue();
        }

        /// <summary>
        /// Tests if the exception message generated by SharpZipLib
        /// equals the one indicating that no password is set.
        /// </summary>
        [TestMethod]
        public async Task ZipFile_GetInputStream_ShouldThrowExceptionWithSpecificMessage_WhenPasswordIsMissing()
        {
            const string archiveName = ArchiveName + "_enc.zip";

            var (_, tempFile) = await Utils.CreateTestFile(_workingDir, "SimpleZIP_testFile_enc").ConfigureAwait(false);
            var archive = await _workingDir.CreateFileAsync(archiveName, CreationCollisionOption.GenerateUniqueName);

            var zipStream = new ZipOutputStream(await archive
                .OpenStreamForWriteAsync().ConfigureAwait(false))
            {
                Password = "test"
            };

            zipStream.SetLevel(0); // no compression needed for this test

            string entryName = ZipEntry.CleanName(tempFile.Name);
            var entry = new ZipEntry(entryName)
            {
                DateTime = DateTime.Now,
                Size = (long)await FileUtils
                    .GetFileSizeAsync(tempFile)
                    .ConfigureAwait(false)
            };

            zipStream.PutNextEntry(entry);
            var buffer = new byte[1 << 12];

            using (var srcStream = await tempFile.OpenStreamForReadAsync().ConfigureAwait(false))
            {
                StreamUtils.Copy(srcStream, zipStream, buffer);
            }

            zipStream.CloseEntry();
            zipStream.IsStreamOwner = true;
            zipStream.Close();

            using (var zipFile = new ZipFile(await archive
                .OpenStreamForReadAsync().ConfigureAwait(false)))
            {
                zipFile.Invoking(f => f.GetInputStream(0)).Should()
                    .Throw<Exception>().WithMessage("No password available*");
            }

            await tempFile.DeleteAsync();
        }

        #region Private methods

        private async Task<bool> PerformArchiveOperations(
            ICompressionAlgorithm compressionAlgorithm,
            string fileType, ICompressionOptions options)
        {
            return await Task.Run(async () =>
            {
                var (content0, tempFile0) = await Utils.CreateTestFile(_workingDir, "SimpleZIP_testFile0").ConfigureAwait(false);
                var (content1, tempFile1) = await Utils.CreateTestFile(_workingDir, "SimpleZIP_testFile1").ConfigureAwait(false);

                var files = new[] { tempFile0, tempFile1 };
                var contents = new[] { content0, content1 };
                string archiveName = ArchiveName + fileType;

                var archive = await _workingDir.CreateFileAsync(archiveName, CreationCollisionOption.GenerateUniqueName);
                await compressionAlgorithm.CompressAsync(files, archive, _workingDir, options).ConfigureAwait(false);

                bool success = await ExtractArchiveAndAssert(compressionAlgorithm, archive.Name, contents).ConfigureAwait(false);

                await tempFile0.DeleteAsync();
                await tempFile1.DeleteAsync();

                return success;

            }).ConfigureAwait(false);
        }

        private async Task<bool> ExtractArchiveAndAssert(
            ICompressionAlgorithm compressionAlgorithm,
            string archiveName, IList<string> expectedContents)
        {
            var archive = await _workingDir.GetFileAsync(archiveName);
            archive.Should().NotBeNull();

            var outputFolder = await _workingDir.CreateFolderAsync(
                "simpleZipUiTempOutput", CreationCollisionOption.ReplaceExisting);

            await compressionAlgorithm.DecompressAsync(archive, outputFolder).ConfigureAwait(false);
            var extractedFiles = await outputFolder.GetFilesAsync(Windows.Storage.Search.CommonFileQuery.DefaultQuery);

            var fileContents = new List<string>();

            foreach (var extractedFile in extractedFiles)
            {
                using (var streamReader = new StreamReader(await extractedFile.OpenStreamForReadAsync().ConfigureAwait(false)))
                {
                    var content = await streamReader.ReadToEndAsync().ConfigureAwait(false);
                    content.Should().NotBeEmpty();
                    fileContents.Add(content);
                }
            }

            foreach (var expectedContent in expectedContents)
            {
                expectedContent.Should().NotBeEmpty();
                fileContents.Should().ContainMatch(expectedContent);
            }

            await outputFolder.DeleteAsync();

            return true;
        }

        #endregion
    }
}